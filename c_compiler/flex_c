
/*Must have all comments and preprocessor instructions removed beforehand*/

%option noyywrap

%{
	/* Add all include headers for the footer here*/
	
	#define DEBUG
	
	#include "./includes/FlexDef.h"
	#include <vector>
	#include <iostream>
	
	using namespace std;
	
	#ifdef DEBUG
	vector<flex_def> tokens;
	#else
	extern vector<flex_def> tokens;
	#endif

%}

AMPERSAND						\&
AUTO							auto
BREAK							break
CASE							case
CHAR_LITERAL					\'([^\'\\]|\\.)\'
CLOSE_BRACKET					\)
CLOSE_CURLY_BRACKET				\}
CLOSE_SQUARE_BRACKET			\]
COLON							:
COMMA							,
CONST_QUALIFIER 				const
CONTINUE						continue
DEFAULT							default
DIVIDE							\/
DO								do
ELLIPSES						\.\.\.
ELSE							else
ENUM							enum
EQUALS							=
EXTERN							extern
FOR								for
FULL_STOP						\.
GOTO							goto
GREATER_THAN					>
IF								if
LESS_THAN						<
MINUS							-
MODULUS							%
MULTIPLY						\*
ID								[A-Za-z_][A-Za-z0-9_]*
NOT								!
NUMBER							[0-9a-zA-Z]+
OPEN_BRACKET					\(
OPEN_CURLY_BRACKET				\{
OPEN_SQUARE_BRACKET				\[
OR								\|
PLUS							\+
QUESTION_MARK					\?
REGISTER						register
RETURN							return
SEMI_COLON						;
SIZEOF							sizeof
STATIC							static
STRING_LITERAL					\"([^\"\\]|\\.)*\"
STRUCT							struct
SWITCH							switch
TILDE							~
TYPE							int|char|double|float|void
TYPEDEF							typedef
TYPE_SPECIFIER_LENGTH			short|long
TYPE_SPECIFIER_SIGNED			signed|unsigned
UNION							union
VOLATILE_QUALIFIER				volatile
WHILE							while
XOR								\^
NUMBER_ID						0[a-zA-Z]

%%

	/*Compare for individual tokens*/
{AMPERSAND}									{flex_def def(ADDRESS_OR_BITWISE_AND_T,YYText());tokens.push_back(def);}
{AMPERSAND}{AMPERSAND}						{flex_def def(LOGICAL_AND_T,YYText());tokens.push_back(def);}
{AUTO}										{flex_def def(AUTO_T,YYText());tokens.push_back(def);}
{BREAK}										{flex_def def(BREAK_T,YYText());tokens.push_back(def);}
{CASE}										{flex_def def(CASE_T,YYText());tokens.push_back(def);}
{CHAR_LITERAL}								{flex_def def(CHAR_T,YYText());tokens.push_back(def);}
{CLOSE_BRACKET}								{flex_def def(CLOSE_BRACKET_T,YYText());tokens.push_back(def);}
{CLOSE_CURLY_BRACKET}						{flex_def def(CLOSE_CURLY_BRACKET_T,YYText());tokens.push_back(def);}
{CLOSE_SQUARE_BRACKET}						{flex_def def(CLOSE_SQUARE_BRACKET_T,YYText());tokens.push_back(def);}
{COLON}										{flex_def def(COLON_T,YYText());tokens.push_back(def);}
{COMMA}										{flex_def def(COMMA_T,YYText());tokens.push_back(def);}
{CONST_QUALIFIER} 							{flex_def def(CONST_T,YYText());tokens.push_back(def);}
{CONTINUE}									{flex_def def(CONTINUE_T,YYText());tokens.push_back(def);}
{DEFAULT}									{flex_def def(DEFAULT_T,YYText());tokens.push_back(def);}
{DIVIDE}|{MODULUS}|{PLUS}|{MINUS}			{flex_def def(ARITHMETIC_T,YYText());tokens.push_back(def);}
{DO}										{flex_def def(DO_T,YYText());tokens.push_back(def);}
{ELLIPSES}									{flex_def def(ELLIPSES_T,YYText());tokens.push_back(def);}
{ELSE}										{flex_def def(ELSE_T,YYText());tokens.push_back(def);}
{ENUM}										{flex_def def(ENUM_T,YYText());tokens.push_back(def);}
{EQUALS}									{flex_def def(EQUALS_T,YYText());tokens.push_back(def);}
{EQUALS}{EQUALS}							{flex_def def(LOGICAL_EQUALS_T,YYText());tokens.push_back(def);}
{EXTERN}									{flex_def def(EXTERN_T,YYText());tokens.push_back(def);}
{FOR}										{flex_def def(FOR_T,YYText());tokens.push_back(def);}
{FULL_STOP}									{flex_def def(FULL_STOP_T,YYText());tokens.push_back(def);}
{GOTO}										{flex_def def(GOTO_T,YYText());tokens.push_back(def);}
{GREATER_THAN}								{flex_def def(GREATER_THAN_T,YYText());tokens.push_back(def);}
{GREATER_THAN}{EQUALS}						{flex_def def(GREATER_THAN_EQUALS_T,YYText());tokens.push_back(def);}
{GREATER_THAN}{GREATER_THAN}				{flex_def def(BITWISE_RIGHT_T,YYText());tokens.push_back(def);}
{IF}										{flex_def def(IF_T,YYText());tokens.push_back(def);}
{LESS_THAN}									{flex_def def(LESS_THAN_T,YYText());tokens.push_back(def);}
{LESS_THAN}{EQUALS}							{flex_def def(LESS_THAN_EQUALS_T,YYText());tokens.push_back(def);}
{LESS_THAN}{LESS_THAN}						{flex_def def(BITWISE_LEFT_T,YYText());tokens.push_back(def);}
{MINUS}{GREATER_THAN}						{flex_def def(POINTER_MEMBER_T,YYText());tokens.push_back(def);}
{MINUS}{ID}									{flex_def def(INVERSE_T,YYText());tokens.push_back(def);}
{MINUS}{MINUS}								{flex_def def(DECREMENT_T,YYText());tokens.push_back(def);}
{MULTIPLY}									{flex_def def(MULT_OR_POINTER_T,YYText());tokens.push_back(def);}
{NOT}										{flex_def def(NOT_T,YYText());tokens.push_back(def);}
{NOT}{EQUALS}								{flex_def def(NOT_EQUALS_T,YYText());tokens.push_back(def);}
{OPEN_BRACKET}								{flex_def def(OPEN_BRACKET_T,YYText());tokens.push_back(def);}
{OPEN_CURLY_BRACKET}						{flex_def def(OPEN_CURLY_BRACKET_T,YYText());tokens.push_back(def);}
{OPEN_SQUARE_BRACKET}						{flex_def def(OPEN_SQUARE_BRACKET_T,YYText());tokens.push_back(def);}
{OR}										{flex_def def(BITWISE_OR_T,YYText());tokens.push_back(def);}
{OR}{OR}									{flex_def def(LOGICAL_OR_T,YYText());tokens.push_back(def);}
{PLUS}{ID}									{flex_def def(TYPE_PROMOTION_T,YYText());tokens.push_back(def);}
{PLUS}{PLUS}								{flex_def def(INCREMENT_T,YYText());tokens.push_back(def);}
{QUESTION_MARK}								{flex_def def(CONDITIONAL_OPERATOR,YYText());tokens.push_back(def);}
{REGISTER}									{flex_def def(REGISTER_T,YYText());tokens.push_back(def);}
{RETURN}									{flex_def def(RETURN_T,YYText());tokens.push_back(def);}
{SEMI_COLON}								{flex_def def(EOS_T,YYText());tokens.push_back(def);}
{SIZEOF}									{flex_def def(SIZEOF_T,YYText());tokens.push_back(def);}
{STATIC}									{flex_def def(STATIC_T,YYText());tokens.push_back(def);}
{STRING_LITERAL}|{CHAR_LITERAL}				{flex_def def(STRING_T,YYText());tokens.push_back(def);}
{STRUCT}									{flex_def def(STRUCT_T,YYText());tokens.push_back(def);}
{SWITCH}									{flex_def def(SWITCH_T,YYText());tokens.push_back(def);}
{TILDE}										{flex_def def(BITWISE_INVERSE_T,YYText());tokens.push_back(def);}
{TYPEDEF}									{flex_def def(TYPEDEF_T,YYText());tokens.push_back(def);}
{TYPE_SPECIFIER_LENGTH}						{flex_def def(TYPE_LENGTH_T,YYText());tokens.push_back(def);}
{TYPE_SPECIFIER_SIGNED}						{flex_def def(TYPE_SIGNED_T,YYText());tokens.push_back(def);}
{TYPE}										{flex_def def(TYPE_T,YYText());tokens.push_back(def);}
{UNION}										{flex_def def(UNION_T,YYText());tokens.push_back(def);}
{VOLATILE_QUALIFIER}						{flex_def def(VOLATILE_T,YYText());tokens.push_back(def);}
{WHILE}										{flex_def def(WHILE_T,YYText());tokens.push_back(def);}
{XOR}										{flex_def def(BITWISE_XOR_T,YYText());tokens.push_back(def);}

	/*The following values may match any of the above so it is best to seperate them*/
{ID}										{flex_def def(ID_T,YYText());tokens.push_back(def);}
{NUMBER_ID}?{NUMBER}L?						{flex_def def(INT_T,YYText());tokens.push_back(def);}
{NUMBER}{FULL_STOP}{NUMBER}L?				{flex_def def(FLOAT_T,YYText());tokens.push_back(def);}
[ \t\n]+									/*Consumes all whitespace*/
.                    						return UNKNOWN;

%%

#ifdef DEBUG
int main()
#else
bool lex()
#endif
{


    yyFlexLexer lexer;
	int lexcode;
	lexcode = lexer.yylex();
	while(lexcode != 0){
		lexcode = lexer.yylex();
		if(lexcode == UNKNOWN)
			#ifdef DEBUG
			break;
			#else
			return false;
			#endif
	}
	#ifdef DEBUG
    for(int i=0; i < tokens.size(); i++)
    	cout << hex <<  tokens[i].Data << " ";
    return 0;
    #else
    return true;
    #endif
}
